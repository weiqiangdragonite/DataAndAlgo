
大话数据结构 - 程杰


Contents


1.数据结构绪论




--------------------------------------------------------------------------------

第1章  数据结构绪论


数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的
学科。

程序设计 = 数据结构 + 算法

数据:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号
集合。

数据元素:是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。

数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

数据对象:是性质相同的数据元素的集合，是数据的子集。


在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。
数据结构:是相互之间存在一种或多种特定关系的数据元素的集舍。


数据结构分为逻辑结构和物理结构

逻辑结构:是指数据对象中数据元素之间的相互关系
逻辑结构分为以下四种:
1. 集合结构
集合结构:集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
2. 线性结构
线性结构:统性结构中的数据元素之间是一对一的关系。
3. 树形结构
树形结构:树形结构中的数据元素之间存在一种一对多的层次关系。
4. 图形结构
图形结构:图形结构的数据元素是多对多的关系。

数据的物理结构，也叫做存储结构。
物理结构:是指数据的逻辑结构在计算机中的存储形式。

数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的
逻辑关系，是实现物理结构的重点和难点。
数据元素的存储结构形式有两种:顺序存储和链式存储。
1. 顺序存储结构
顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
2. 链式存储结构
链式存储结构:是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就
可以找到相关联数据元素的位置。

逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到
计算机的内存中。


数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

在C语言中，按照取值的不同，数据类型可以分为两类;
原子类型:是不可以再分解的基本类型，包括整型、实型、字符型等。
结构类型:由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。

抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个
概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。

抽象数据类型(Abstract Data Type，ADT) : 是指一个数学模型及定义在该模型上的一组操作。
一个抽象数据类型定义了:一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。

事实上，抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的
问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的
实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。


描述抽象数据类型的标准格式:

ADT	抽象数据类型名
Data
	数据元素之间逗得关系的定义
Operation
	操作1
		初始条件
		操作结果描述
	操作2
		......
	操作n
		......
endADT


总结：
+------------------------------------+
|                数据                 |
+------------------------------------+
|               数据对象              |
+-----------------++-----------------+
|     数据元素     ||     数据元素      |
+--------+--------++--------+--------+
| 数据项1 | 数据项2 || 数据项1 | 数据项2 |
+--------+--------++--------+--------+

+-----------+
|  逻辑结构  |
+-----------+
| - 集合结构 |
| - 线性结构 |
| - 树形结构 |
| - 图形结构 |
+-----------+

+--------------+
|    物理结构   |
+--------------+
| - 顺序存储结构 |
| - 链接存储结构 |
+--------------+


--------------------------------------------------------------------------------

第2章  算法


在《数据结构》课程中，就算谈到算法，也是为了帮助理解好数据结构，并不会详细谈及算法的方方面面。

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特性: 输入、输出、有穷性、确定性和可行性。

输入和输出：
算法具有零个或多个输入，算法至少有一个或多个输出。
有穷性：
指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
确定性：
算法的每一步骤都具有确定的含义，不会出现二义性。
可行性：
算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

算法不是唯一的，也就是说，同一个问题，可以有多种解决问题的算法。


正确性:算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、
能够得到问题的正确答案。
算法的"正确"通常在用法上有很大的差别，大体分为以下四个层次。
1. 算法程序没有语法错误。
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。
算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有
层次上都是正确的，代价非常昂贵。所以一般情况下，把层次3作为一个算法是否正确的标准。

可读性: 算法设计的另一目的是为了便于阅读、理解和交流。
我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和
交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。

健壮性:当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

时间效率高和存储量低:好的算法还应该具备时间效率高和存储量低的特点。

综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。


算法效率的度量方法

事后统计方法:这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的
运行时间进行比较，从而确定算法效率的高低。
事前分析估算方法:在计算机程序编制前，依据统计方法对算法进行估算。

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素:
1. 算法采用的策略、方法。
2. 编译产生的代码质量。
3. 问题的输入规模。
4. 机器执行指令的速度。
一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。


第一个例子
写一个求1+2+3+...+100结果的程序

版本一：
int i, sum, n;
sum = 0, n = 100;
for (i = 1; i <= n; ++i)
	sum += i;		/* 执行n次 */

版本二：
int i, sum, n;
sum = 0, n = 100;
sum = (1 + n) * n / 2;		/* 执行1次 */

我们把循环看作一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是n次与1次的差距。


第二个例子

int i, j, x = 0, sum = 0, n = 100;
for (i = 1; i <= n; ++i) {
	for (j = 1; j <= n; ++j) {
		++x;
		sum += x;	/* 执行nxn次 */
	}
}
这个例子中，i从1到100，每次都要让j循环100次，而当中的x++和sum = sum + x; 其实就是
1+2+3+...+10000，也就是100^2次。所以这个算法当中，循环部分的代码整体需要执行n^2 
(忽略循环体头尾的开销)次。


测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数，运行时间与这个计数成正比。

我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心
它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变童声明、打印结果等操作，最终，
在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。

可以从问题描述中得到启示，同样问题的输入规模是n，求和算法的第一种，求1+2+...+n需要一段代码
运行n次。那么这个问题的输入规模使得操作数量是 f(n) = n，显然运行100次的同一段代码规模是运算
10次的10倍。而第二种，无论n为多少，运行次数都为1，即 f(n) = 1; 第三种，运算100次是运算10次
的100倍。因为它是 f(n) = n^2。

我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量
必须表示成输入规模的函数。
我们可以这样认为，随着n值的越来越大，它们在时间效率上的差异也就越来越大。


输入规模n 在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是
渐近增长的。
函数的渐近增长:给定两个函数 f(n) 和 g(n)，如果存在一个整数N，使得对于所有的 n > N,
f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。

我们可以忽略这些加法常数；
与最高次项相乘的常数并不重要
最高次项的指数大的，函数随着 n 的增长，结果也会变得增长特别快。

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数。

某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。这其实就是事前估算方法
的理论依据，通过算法时间复杂度来估算算法时间效率。


算法时间复杂度定义

在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化
情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作: T(n) = O(f(n))。
它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，
简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函敬。

这样用大写 O() 来体现算法时间复杂度的记法，我们称之为 大O记法。
一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。
显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为 O(n)，O(1)，O(n^2)。
我们分别给它们取了非官方的名称，O(1) 叫常数阶、O(n) 叫线性阶、O(n^2) 叫平方阶。


推导大O阶:
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常敢。
得到的结果就是大O阶。


常数阶
首先顺序结构的时间复杂度。
int sum = 0, n = 100;	/* 执行一次 */
sum = (1 + n) / 2;	/* 执行一次 */
printf("%d", sum);	/* 执行一次 */
这个算法的时间复杂度为 O(1)。
这种与问题的大小无关( n 的多少)，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度，又
叫常数阶。

线性阶
线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行
的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。
int i;
for (i = 0; i < n; ++i) {
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
循环的时间复杂度为 O(n)，因为循环体中的代码须要执行n次。

对数阶
int count = 1;
while (count < n) {
	count = count * 2;
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
由于每次 count 乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。
由 2^x=n 得到 x=log2(n)。所以这个循环的时间复杂度为 O(log n)。

平方阶
int i, j;
for (i = 0; i < n; ++i) {
	for (j = 0; j < n; ++j) {
		/* 时间复杂度为 O(1) 的程序步骤序列 */
	}
}
对于外层的循环，不过是内部这个时间复杂度为O(n)的语旬，再循环n次。所以这段代码的时间复杂度为
O(n^2).


常用的时间复杂度所耗费的时间从小到大依次是:
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
常数阶  对数阶    线性阶   nlogn阶    平方阶     立方阶    指数阶   阶乘阶


最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，
除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。
对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另
一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，
都是指最坏时间复杂度。


算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作: 
S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。


--------------------------------------------------------------------------------

第三章  线性表


线性表(List):零个或多个数据元素的有限序列。

若将线性表记为(a1, ... , ai-1, ai, ai+1, ... , an)，则表中 ai-1 领先于 ai，ai 领
先于 ai+1，称 ai-1 是 ai 的直接前驱元素， ai+1 是 ai 的直接后继元素。当 i=1, 2, ... ,
n-1 时， ai 有且仅有一个直接后继，当 i=2, 3, ... , n 时，ai 有且仅有一个直接前驱。

线性表元素的个数 n( n >= 0 ) 定义为线性表的长度，当 n=0 时，称为空表。
在较复杂的线性表中，一个数据元素可以由若干个数据项组成。


线性表的抽象数据类型定义如下:

ADT 线性表(List)
Data
	线性表的数据对象集合为 {a1, a2, ... , an}，每个元素的类型均为 DataType。其中，
	除第一个元素 a1 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，
	每一个元素有且只有一个后继元素。数据元素之间的关系是一对一的关系。
Operation
	InitList(*L) : 初始化操作，建立一个空的线性表 L。
	ListEmpty(L) : 若线性表为空，返回true，否则返回false。
	ClearList(*L) : 将线性表清空。
	GetElem(L, i, *e) : 将线性表 L 中的第 i 个位置元素值返回给 e。
	LocateElem(L, e) : 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回
                           该元素在表中序号表示成功；否则，返回0表示失败。
	ListInsert(*L, i, e) : 在线性表 L 中的第 i 个位置插入新元素 e。
	ListDelete(*L, i, *e) : 删除线性表 L 中第 i 个位置元素，并用 e 返回其值。
	ListLength(L) : 返回线性表 L 的元素个数。
endADT


线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

线性表的顺序存储的结构代码：
#define MAXSIZE	20	/* 存储空间的初始分配量 */
typedef int ElemType;	/* ElemType 类型根据实际情况而定 */
typedef struct sequence_list {
	ElemType data[MAXSIZE];	/* 数组存储数据元素，最大值为MAXSIZE */
	int length;		/* 线性表当前长度 */
};

描述顺序存储结构需要三个属性:
1. 存储空间的起始位置: 数组data，它的存储位置就是存储空间的存储位置。
2. 线性表的最大存储容量: 数组长度MAXSIZE。
3. 线性表的当前长度: length。

在任意时刻，线性表的长度应该小于等于数组的长度。

假设每个数据元素占用 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的
存储位置满足下列关系(LOC 表示获得存储位置的函数):
LOC(ai+1) = LOC(ai) + c
对于第 i 个数据元素 ai 的存储位置可以由 a1 推算得出:
LOC(ai) = LOC(a1) + (i-1) * c

我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间,也就是一个常数，因此用
我们算法中学到的时间复杂度的概念来说，它的存取时间性能为 O(1)。我们通常把具有这一特点的
存储结构称为随机存取结构。

插入算法的思路;
1. 如果插入位置不合理，抛出异常;
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量;
3. 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置;
4. 将要插入元素填入位置 i 处;
5. 表长加1。

删除算法的思路:
1. 如果删除位置不合理，抛出异常；
2. 取出删除元素;
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置;
4. 表长减1。

如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为 O(1)
如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，
所以这个时间复杂度为 O(n)。
至于平均的情况，由于元素插入到第 i 个位置，或删除第 i 个元素，需要移动 n - i 个元素。最终
平均移动次数和最中间的那个元素的移动次数相等，为 (n-1)/2。可以得出，平均时间复杂度还是 O(n)。

线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 O(1); 
而插入或删除时，时间复杂度都是 O(n)。



线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，
也可以是不连续的。

在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。

为了表示每个数据元素 ai 与其直接后继数据元素 ai+1 之间的逻辑关系，对数据元素 ai 来说，除了
存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据
元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。
这两部分信息组成数据元素 ai 的存储映像，称为结点(Node) 。

n个结点(ai 的存储映像) 链结成一个链表，即为线性表( a1, a2, ... , an ) 的链式存储结构，
因为此链表的每个结点中只包含一个指针域，所以叫做单链表。

链表中第一个结点的存储位置叫做头指针。最后一个，当然就意味着直接后继不存在了，所以我们规定，
线性链表的最后一个结点指针为"空" (通常用 NULL 或 ^ 符号表示)

头指针
+----+-+   +----+-+           +----+------+
| a1 | +-->| a2 | +--> ... -->| an | NULL |
+----+-+   +----+-+           +----+------+

有时，我们为了更加方便地对链装进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。
头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针。

头结点
+--+-+   +----+-+   +----+-+           +----+------+
|  | +-->| a1 | +-->| a2 | +--> ... -->| an | NULL |
+--+-+   +----+-+   +----+-+           +----+------+


头指针是一个指针，指向头结点
头节点的next指针指向第一个节点
第一个节点是一个节点，data变量存放第一个数据，next指针变量指向第二个节点


线性表的存储结构
struct link_list {
	ElemType data;
	struct link_list next;
};

             p            p->next
          +------+-+   +--------+-+
       -->|  ai  | +-->|  ai+1  | +-->
          +--+---+-+   +---+----+-+
             |             |
             V             V
         p->data       p->next->data

获得单链表第 i 个数据的算法思路:
1.声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始;
2.当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1;
3.若到链表末尾 p 为空，则说明第 i 个元素不存在;
4.否则查找成功，返回结点 p 的数据。

单链表第 i 个数据插入结点的算法思路:
1.声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始
2.当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1;
3.若到链表末尾 p 为空，则说明第 i 个元素不存在
4.否则查找成功，在系统中生成一个空结点 s;
5.将数据元素 e 赋值给 s->data ;
6.单链表的插入标准语句 s->next=p->next, p->next=s
7.返回成功。

单链表第 i 个数据删除结点的算法思路:
1.声明一结点 p 指向链表第一个结点， 初始化 j 从1 开始
2.当 j<i 时，就遍历链表， 让 p 的指针向后移动，不断指向下一个结点，j 累加 1
3.若到链表末尾 p 为空，则说明第 i 个元素不存在;
4.否则查找成功，将欲删除的结点 p->next 赋值给q;
5.单链表的删除标准语句 p->next=q->next;
6.将 q 结点中的数据赋值给 e ，作为返回;
7.释放 q 结点;
8.返回成功。

单链表整表创建的算法思路:
1.声明一结点 p 和计数器变量 i;
2.初始化一空链表L;
3.让 L 的头结点的指针指向NULL，即建立一个带头结点的单链表
4.循环:
  生成一新结点赋值给 p;
  随机生成一数字赋值给 p 的数据域 p->data;
  将 p 插入到头结点与前一新结点之间。

头插法 和 尾插法

单链表整表删除的算法思路如下:
1.声明一结点 p 和q ;
2.将第一个结点赋值给p;
3.循环:
  将下一结点赋值给q;
  释放p;
  将 q 赋值给p 。



单链表结构与顺序存储结构优缺点

存储分配方式:
1.顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
2.单链表采用链式存储 结构，用一组任意的存储单元存放线性表的元素

时间性能:
1.查找
  顺序存储结构 O(1)
  单链表 O(1)
2.插入和删除
  顺序存储结构需要平均移动表长一半的元素，时间为 O(n)
  单链表在找出某位置的指针后，插入和删除时间为 O(1)

空间性能:
1.顺序存储结构需要预分配存储空间，分大了，浪费，分小了，易发生溢出
2.单链表不需要预分配存储空间，需要用时就可以分配，元素也不受限制

若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，
宜采用单链表结构。
当线性表中的元素个数变化较大或者根本不知道有多大肘，最好用单链表结构，这样可以不需要考虑
存储空间的大小问题。


静态链表
#define LIST_SIZE 1000
struct static_list {
	ElemType data;
	int cursor;	/* 游标 */
};

优点：
在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插人和删除操作
需要移动大量元素的缺点
缺点：
没有解决连续存储分配带来的表长难以确定的问题；
失去了顺序存储结构随机存取的特性


循环链表

将单链表中终端结点的指针端自空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的
单链表称为单循环链表，简称循环链表(circular linked list) 。
（尾指针 rear）


双向链表

双向链表(double linked List) 是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。
所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。

struct node {
	ElemType data;
	struct node *prior;
	struct node *next;
};


--------------------------------------------------------------------------------

第4章 栈与队列


栈(stack)是限定仅在表尾进行捕入和删除操作的线性表。

我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空钱。
栈又称为后进先出(Last In First Out)的线性表，简称 LlFO 结构。

理解栈的定义：
首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。
定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。

栈的插入操作，叫作进栈，也称压栈、入栈。
栈的删除操作，叫作出栈，也有的叫作弹栈。

栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有
元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。


栈的抽象数据类型

ADT 栈(stack)
Data
	同线性表。元索具有相同的类型，相邻元素具有前驱和后继关系。
Operation
	InitStack(*S) : 初始化操作，建立一个空栈S。
	DestroyStack(*S) : 若栈存在，则销毁它。
	ClearStack(*S) : 将栈清空。
	StackEmpty(S) : 若栈为空，返回true，否则返回false。
	GetTop(S, *e) : 若栈存在且非空，用e返回S的栈顶元素。
	Push(*S，e) : 若栈S存在，插入新元素e到栈S中并成为栈顶元素。
	Pop(*S，*e) : 删除栈s中栈顶元素，并用e返回其值。
	StackLength(s) : 返回栈S的元素个数。
endADT

由于栈本身就是一个线性表，那么上一章我们讨论了线性表的顺序存储和链式存储，对于栈来说，
也是同样适用的。


栈的顺序存储结构及实现

当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为 top 等于 -1。

struct stack {
	ElemType data[MAXSIZE];
	int top; / *用于我顶指针* /
};

                                         +----+
           |    |       |    |  top -> 2 | a2 |
           +----+       +----+           +----+
 top -> 1  | a2 |       |    |         1 | a1 |
           +----+       +----+           +----+
        0  | a1 |       |    |         0 | a0 |
           +----+       +----+           +----+
       栈有两个元素，    空栈，top = -1      满栈，top = 2
       top = 1


两栈共享空间

这只是针对两个具有相同数据类型的栈的一个设计上的技巧。
使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。

数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，
即下标为数组长度 n - 1 处。这样，两个栈如果增加元素，就是两端点向中间延伸。

关键思路是:它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针。

栈1为空时，就是top1等于-1时; 而当top2等于n时，即是栈2为空。
若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。
但更多的情况，其实就是刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top+1 == top2
为栈满。


struct double_stack {
	ElemType data(MAXSTZE];
	int top1; /* 栈1栈顶指针 */
	int top2; /* 栈2栈顶指针 */
};

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号
参数stackNumber。

int
push(double_stack_t *stack, ElemType *item, int num)
{
	/* if full */
	if (stack->top1 + 1 == stack->top2)
		return -1;

	/* 若栈1，则先top1+1后给数组元素赋值 */
	if (num == 1)
		stack->data[++stack->top1] = item;
	/* 若栈2，则先top2-1后给数组元素赋值 */
	else
		stack->data[--stack->top2] = item;

	return 0;
}

int
pop(double_stack_t *stack, ElemType *item, int num)
{
	if (num == 1) {
		/* if empty */
		if (stack->top1 == -1)
			return -1;

		*item = stack->data[stack->top1--];
	} else {
		if (stack->top2 == STACK_SIZE)
			return -1;

		*item = stack->data[stack->top2++];
	}

	return 0;
}



栈的链式存储结构及实现

栈的链式存储结构，简称为链栈。
通常对于链栈来说，是不需要头结点的。

                +----+-+   +------+-+           +----+------+
   头指针 top--->| an | +-->| an-1 | +--> ... -->| a1 | NULL |
                +----+-+   +------+-+           +----+------+
                 栈顶                             栈底

对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间。
对于空栈来说，链表原定义是头指针指向空， 那么链栈的空其实就是top=NULL的时候。


struct node {
	ElemType data;
	struct node next;
};

struct link_stack {
	struct node top;
	unsigned int count;
};


链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)。
对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1) 。对于空间性能，顺序栈需要事先
确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求
每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中
讨论的一样， 如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，
如果它的变化在可控范围内，建议使用顺序栈会更好一些。


栈的应用 - 递归

斐波那契(Fibonacci)
如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔都不死，
那么一年以后可以繁殖多少对兔子呢?

这个数列有个十分明显的特点，那是:前面相邻两项之和，构成了后一项。

       /-  0，当n=O
F(n)= < -  1，当n=1
       \-  F(n-1)+F(n-2)，当n>1

int
fibonacci(int n)
{
	if (n < 2)
		return (n == 0) ? 0 : 1;
	else
		return fibonacci(n-1) + fibonacci(n-2);
}

把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。
每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理
解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。
迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。



栈的应用 - 四则运算表达式求值

后缀（逆波兰）表示法

对于"9+(3-1)*3+10/2"，如果要用后缀表示法应该是什么样子:"9 3 1 - 3 * + 10 2 / +"，
这样的表达式称为后缀表达式。所有的符号都是在要运算数字的后面出现。

后缀表达式的计算
规则:从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，
进行运算，运算结果进栈，一直到最终获得结果。

中缀表达式(infix expression) 转 后缀表达式(postfix expression)
规则: 从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；
若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于前一个符号(乘除优先加减)则栈顶元素
依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

要想让计算机具有处理我们通常的标准(中缀)表达式的能力，最重要的就是两步:
1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。
2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。












