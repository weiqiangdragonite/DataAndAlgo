
大话数据结构 - 程杰


Contents


1.数据结构绪论




--------------------------------------------------------------------------------

第1章  数据结构绪论


数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的
学科。

程序设计 = 数据结构 + 算法

数据:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号
集合。

数据元素:是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。

数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

数据对象:是性质相同的数据元素的集合，是数据的子集。


在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。
数据结构:是相互之间存在一种或多种特定关系的数据元素的集舍。


数据结构分为逻辑结构和物理结构

逻辑结构:是指数据对象中数据元素之间的相互关系
逻辑结构分为以下四种:
1. 集合结构
集合结构:集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
2. 线性结构
线性结构:线性结构中的数据元素之间是一对一的关系。
3. 树形结构
树形结构:树形结构中的数据元素之间存在一种一对多的层次关系。
4. 图形结构
图形结构:图形结构的数据元素是多对多的关系。

数据的物理结构，也叫做存储结构。
物理结构:是指数据的逻辑结构在计算机中的存储形式。

数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的
逻辑关系，是实现物理结构的重点和难点。
数据元素的存储结构形式有两种:顺序存储和链式存储。
1. 顺序存储结构
顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
2. 链式存储结构
链式存储结构:是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就
可以找到相关联数据元素的位置。

逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到
计算机的内存中。


数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

在C语言中，按照取值的不同，数据类型可以分为两类;
原子类型:是不可以再分解的基本类型，包括整型、实型、字符型等。
结构类型:由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。

抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个
概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。

抽象数据类型(Abstract Data Type，ADT) : 是指一个数学模型及定义在该模型上的一组操作。
一个抽象数据类型定义了:一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。

事实上，抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的
问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的
实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。


描述抽象数据类型的标准格式:

ADT	抽象数据类型名
Data
	数据元素之间逗得关系的定义
Operation
	操作1
		初始条件
		操作结果描述
	操作2
		......
	操作n
		......
endADT


总结：
+------------------------------------+
|                数据                 |
+------------------------------------+
|               数据对象              |
+-----------------++-----------------+
|     数据元素     ||     数据元素      |
+--------+--------++--------+--------+
| 数据项1 | 数据项2 || 数据项1 | 数据项2 |
+--------+--------++--------+--------+

+-----------+
|  逻辑结构  |
+-----------+
| - 集合结构 |
| - 线性结构 |
| - 树形结构 |
| - 图形结构 |
+-----------+

+--------------+
|    物理结构   |
+--------------+
| - 顺序存储结构 |
| - 链接存储结构 |
+--------------+


--------------------------------------------------------------------------------

第2章  算法


在《数据结构》课程中，就算谈到算法，也是为了帮助理解好数据结构，并不会详细谈及算法的方方面面。

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特性: 输入、输出、有穷性、确定性和可行性。

输入和输出：
算法具有零个或多个输入，算法至少有一个或多个输出。
有穷性：
指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
确定性：
算法的每一步骤都具有确定的含义，不会出现二义性。
可行性：
算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

算法不是唯一的，也就是说，同一个问题，可以有多种解决问题的算法。


正确性:算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、
能够得到问题的正确答案。
算法的"正确"通常在用法上有很大的差别，大体分为以下四个层次。
1. 算法程序没有语法错误。
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。
算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有
层次上都是正确的，代价非常昂贵。所以一般情况下，把层次3作为一个算法是否正确的标准。

可读性: 算法设计的另一目的是为了便于阅读、理解和交流。
我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和
交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。

健壮性:当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

时间效率高和存储量低:好的算法还应该具备时间效率高和存储量低的特点。

综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。


算法效率的度量方法

事后统计方法:这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的
运行时间进行比较，从而确定算法效率的高低。
事前分析估算方法:在计算机程序编制前，依据统计方法对算法进行估算。

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素:
1. 算法采用的策略、方法。
2. 编译产生的代码质量。
3. 问题的输入规模。
4. 机器执行指令的速度。
一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。


第一个例子
写一个求1+2+3+...+100结果的程序

版本一：
int i, sum, n;
sum = 0, n = 100;
for (i = 1; i <= n; ++i)
	sum += i;		/* 执行n次 */

版本二：
int i, sum, n;
sum = 0, n = 100;
sum = (1 + n) * n / 2;		/* 执行1次 */

我们把循环看作一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是n次与1次的差距。


第二个例子

int i, j, x = 0, sum = 0, n = 100;
for (i = 1; i <= n; ++i) {
	for (j = 1; j <= n; ++j) {
		++x;
		sum += x;	/* 执行nxn次 */
	}
}
这个例子中，i从1到100，每次都要让j循环100次，而当中的x++和sum = sum + x; 其实就是
1+2+3+...+10000，也就是100^2次。所以这个算法当中，循环部分的代码整体需要执行n^2 
(忽略循环体头尾的开销)次。


测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数，运行时间与这个计数成正比。

我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心
它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变童声明、打印结果等操作，最终，
在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。

可以从问题描述中得到启示，同样问题的输入规模是n，求和算法的第一种，求1+2+...+n需要一段代码
运行n次。那么这个问题的输入规模使得操作数量是 f(n) = n，显然运行100次的同一段代码规模是运算
10次的10倍。而第二种，无论n为多少，运行次数都为1，即 f(n) = 1; 第三种，运算100次是运算10次
的100倍。因为它是 f(n) = n^2。

我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量
必须表示成输入规模的函数。
我们可以这样认为，随着n值的越来越大，它们在时间效率上的差异也就越来越大。


输入规模n 在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是
渐近增长的。
函数的渐近增长:给定两个函数 f(n) 和 g(n)，如果存在一个整数N，使得对于所有的 n > N,
f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。

我们可以忽略这些加法常数；
与最高次项相乘的常数并不重要
最高次项的指数大的，函数随着 n 的增长，结果也会变得增长特别快。

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数。

某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。这其实就是事前估算方法
的理论依据，通过算法时间复杂度来估算算法时间效率。


算法时间复杂度定义

在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化
情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作: T(n) = O(f(n))。
它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，
简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函敬。

这样用大写 O() 来体现算法时间复杂度的记法，我们称之为 大O记法。
一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。
显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为 O(n)，O(1)，O(n^2)。
我们分别给它们取了非官方的名称，O(1) 叫常数阶、O(n) 叫线性阶、O(n^2) 叫平方阶。


推导大O阶:
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常敢。
得到的结果就是大O阶。


常数阶
首先顺序结构的时间复杂度。
int sum = 0, n = 100;	/* 执行一次 */
sum = (1 + n) / 2;	/* 执行一次 */
printf("%d", sum);	/* 执行一次 */
这个算法的时间复杂度为 O(1)。
这种与问题的大小无关( n 的多少)，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度，又
叫常数阶。

线性阶
线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行
的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。
int i;
for (i = 0; i < n; ++i) {
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
循环的时间复杂度为 O(n)，因为循环体中的代码须要执行n次。

对数阶
int count = 1;
while (count < n) {
	count = count * 2;
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
由于每次 count 乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。
由 2^x=n 得到 x=log2(n)。所以这个循环的时间复杂度为 O(log n)。

平方阶
int i, j;
for (i = 0; i < n; ++i) {
	for (j = 0; j < n; ++j) {
		/* 时间复杂度为 O(1) 的程序步骤序列 */
	}
}
对于外层的循环，不过是内部这个时间复杂度为O(n)的语旬，再循环n次。所以这段代码的时间复杂度为
O(n^2).


常用的时间复杂度所耗费的时间从小到大依次是:
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
常数阶  对数阶    线性阶   nlogn阶    平方阶     立方阶    指数阶   阶乘阶


最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，
除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。
对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另
一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，
都是指最坏时间复杂度。


算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作: 
S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。


--------------------------------------------------------------------------------

第三章  线性表


线性表(List):零个或多个数据元素的有限序列。

若将线性表记为(a1, ... , ai-1, ai, ai+1, ... , an)，则表中 ai-1 领先于 ai，ai 领
先于 ai+1，称 ai-1 是 ai 的直接前驱元素， ai+1 是 ai 的直接后继元素。当 i=1, 2, ... ,
n-1 时， ai 有且仅有一个直接后继，当 i=2, 3, ... , n 时，ai 有且仅有一个直接前驱。

线性表元素的个数 n( n >= 0 ) 定义为线性表的长度，当 n=0 时，称为空表。
在较复杂的线性表中，一个数据元素可以由若干个数据项组成。


线性表的抽象数据类型定义如下:

ADT 线性表(List)
Data
	线性表的数据对象集合为 {a1, a2, ... , an}，每个元素的类型均为 DataType。其中，
	除第一个元素 a1 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，
	每一个元素有且只有一个后继元素。数据元素之间的关系是一对一的关系。
Operation
	InitList(*L) : 初始化操作，建立一个空的线性表 L。
	ListEmpty(L) : 若线性表为空，返回true，否则返回false。
	ClearList(*L) : 将线性表清空。
	GetElem(L, i, *e) : 将线性表 L 中的第 i 个位置元素值返回给 e。
	LocateElem(L, e) : 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回
                           该元素在表中序号表示成功；否则，返回0表示失败。
	ListInsert(*L, i, e) : 在线性表 L 中的第 i 个位置插入新元素 e。
	ListDelete(*L, i, *e) : 删除线性表 L 中第 i 个位置元素，并用 e 返回其值。
	ListLength(L) : 返回线性表 L 的元素个数。
endADT


线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

线性表的顺序存储的结构代码：
#define MAXSIZE	20	/* 存储空间的初始分配量 */
typedef int ElemType;	/* ElemType 类型根据实际情况而定 */
typedef struct sequence_list {
	ElemType data[MAXSIZE];	/* 数组存储数据元素，最大值为MAXSIZE */
	int length;		/* 线性表当前长度 */
};

描述顺序存储结构需要三个属性:
1. 存储空间的起始位置: 数组data，它的存储位置就是存储空间的存储位置。
2. 线性表的最大存储容量: 数组长度MAXSIZE。
3. 线性表的当前长度: length。

在任意时刻，线性表的长度应该小于等于数组的长度。

假设每个数据元素占用 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的
存储位置满足下列关系(LOC 表示获得存储位置的函数):
LOC(ai+1) = LOC(ai) + c
对于第 i 个数据元素 ai 的存储位置可以由 a1 推算得出:
LOC(ai) = LOC(a1) + (i-1) * c

我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间,也就是一个常数，因此用
我们算法中学到的时间复杂度的概念来说，它的存取时间性能为 O(1)。我们通常把具有这一特点的
存储结构称为随机存取结构。

插入算法的思路;
1. 如果插入位置不合理，抛出异常;
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量;
3. 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置;
4. 将要插入元素填入位置 i 处;
5. 表长加1。

删除算法的思路:
1. 如果删除位置不合理，抛出异常；
2. 取出删除元素;
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置;
4. 表长减1。

如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为 O(1)
如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，
所以这个时间复杂度为 O(n)。
至于平均的情况，由于元素插入到第 i 个位置，或删除第 i 个元素，需要移动 n - i 个元素。最终
平均移动次数和最中间的那个元素的移动次数相等，为 (n-1)/2。可以得出，平均时间复杂度还是 O(n)。

线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 O(1); 
而插入或删除时，时间复杂度都是 O(n)。



线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，
也可以是不连续的。

在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。

为了表示每个数据元素 ai 与其直接后继数据元素 ai+1 之间的逻辑关系，对数据元素 ai 来说，除了
存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据
元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。
这两部分信息组成数据元素 ai 的存储映像，称为结点(Node) 。

n个结点(ai 的存储映像) 链结成一个链表，即为线性表( a1, a2, ... , an ) 的链式存储结构，
因为此链表的每个结点中只包含一个指针域，所以叫做单链表。

链表中第一个结点的存储位置叫做头指针。最后一个，当然就意味着直接后继不存在了，所以我们规定，
线性链表的最后一个结点指针为"空" (通常用 NULL 或 ^ 符号表示)

头指针
    +----+-+   +----+-+           +----+------+
 -->| a1 | +-->| a2 | +--> ... -->| an | NULL |
    +----+-+   +----+-+           +----+------+

有时，我们为了更加方便地对链装进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。
头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针。

头结点
+--+-+   +----+-+   +----+-+           +----+------+
|  | +-->| a1 | +-->| a2 | +--> ... -->| an | NULL |
+--+-+   +----+-+   +----+-+           +----+------+


头指针是一个指针，指向头结点
头节点的next指针指向第一个节点
第一个节点是一个节点，data变量存放第一个数据，next指针变量指向第二个节点


线性表的存储结构
struct link_list {
	ElemType data;
	struct link_list next;
};

             p            p->next
          +------+-+   +--------+-+
       -->|  ai  | +-->|  ai+1  | +-->
          +--+---+-+   +---+----+-+
             |             |
             V             V
         p->data       p->next->data

获得单链表第 i 个数据的算法思路:
1.声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始;
2.当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1;
3.若到链表末尾 p 为空，则说明第 i 个元素不存在;
4.否则查找成功，返回结点 p 的数据。

单链表第 i 个数据插入结点的算法思路:
1.声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始
2.当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1;
3.若到链表末尾 p 为空，则说明第 i 个元素不存在
4.否则查找成功，在系统中生成一个空结点 s;
5.将数据元素 e 赋值给 s->data ;
6.单链表的插入标准语句 s->next=p->next, p->next=s
7.返回成功。

单链表第 i 个数据删除结点的算法思路:
1.声明一结点 p 指向链表第一个结点， 初始化 j 从1 开始
2.当 j<i 时，就遍历链表， 让 p 的指针向后移动，不断指向下一个结点，j 累加 1
3.若到链表末尾 p 为空，则说明第 i 个元素不存在;
4.否则查找成功，将欲删除的结点 p->next 赋值给q;
5.单链表的删除标准语句 p->next=q->next;
6.将 q 结点中的数据赋值给 e ，作为返回;
7.释放 q 结点;
8.返回成功。

单链表整表创建的算法思路:
1.声明一结点 p 和计数器变量 i;
2.初始化一空链表L;
3.让 L 的头结点的指针指向NULL，即建立一个带头结点的单链表
4.循环:
  生成一新结点赋值给 p;
  随机生成一数字赋值给 p 的数据域 p->data;
  将 p 插入到头结点与前一新结点之间。

头插法 和 尾插法

单链表整表删除的算法思路如下:
1.声明一结点 p 和q ;
2.将第一个结点赋值给p;
3.循环:
  将下一结点赋值给q;
  释放p;
  将 q 赋值给p 。



单链表结构与顺序存储结构优缺点

存储分配方式:
1.顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
2.单链表采用链式存储 结构，用一组任意的存储单元存放线性表的元素

时间性能:
1.查找
  顺序存储结构 O(1)
  单链表 O(1)
2.插入和删除
  顺序存储结构需要平均移动表长一半的元素，时间为 O(n)
  单链表在找出某位置的指针后，插入和删除时间为 O(1)

空间性能:
1.顺序存储结构需要预分配存储空间，分大了，浪费，分小了，易发生溢出
2.单链表不需要预分配存储空间，需要用时就可以分配，元素也不受限制

若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，
宜采用单链表结构。
当线性表中的元素个数变化较大或者根本不知道有多大肘，最好用单链表结构，这样可以不需要考虑
存储空间的大小问题。


静态链表
#define LIST_SIZE 1000
struct static_list {
	ElemType data;
	int cursor;	/* 游标 */
};

优点：
在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插人和删除操作
需要移动大量元素的缺点
缺点：
没有解决连续存储分配带来的表长难以确定的问题；
失去了顺序存储结构随机存取的特性


循环链表

将单链表中终端结点的指针端自空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的
单链表称为单循环链表，简称循环链表(circular linked list) 。
（尾指针 rear）


双向链表

双向链表(double linked List) 是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。
所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。

struct node {
	ElemType data;
	struct node *prior;
	struct node *next;
};


--------------------------------------------------------------------------------

第4章 栈与队列


栈(stack)是限定仅在表尾进行捕入和删除操作的线性表。

我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空钱。
栈又称为后进先出(Last In First Out)的线性表，简称 LIFO 结构。

理解栈的定义：
首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。
定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。

栈的插入操作，叫作进栈，也称压栈、入栈。
栈的删除操作，叫作出栈，也有的叫作弹栈。

栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有
元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。


栈的抽象数据类型

ADT 栈(stack)
Data
	同线性表。元索具有相同的类型，相邻元素具有前驱和后继关系。
Operation
	InitStack(*S) : 初始化操作，建立一个空栈S。
	DestroyStack(*S) : 若栈存在，则销毁它。
	ClearStack(*S) : 将栈清空。
	StackEmpty(S) : 若栈为空，返回true，否则返回false。
	GetTop(S, *e) : 若栈存在且非空，用e返回S的栈顶元素。
	Push(*S，e) : 若栈S存在，插入新元素e到栈S中并成为栈顶元素。
	Pop(*S，*e) : 删除栈s中栈顶元素，并用e返回其值。
	StackLength(s) : 返回栈S的元素个数。
endADT

由于栈本身就是一个线性表，那么上一章我们讨论了线性表的顺序存储和链式存储，对于栈来说，
也是同样适用的。


栈的顺序存储结构及实现

当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为 top 等于 -1。

struct stack {
	ElemType data[MAXSIZE];
	int top; / *用于我顶指针* /
};

                                         +----+
           |    |       |    |  top -> 2 | a2 |
           +----+       +----+           +----+
 top -> 1  | a2 |       |    |         1 | a1 |
           +----+       +----+           +----+
        0  | a1 |       |    |         0 | a0 |
           +----+       +----+           +----+
       栈有两个元素，    空栈，top = -1      满栈，top = 2
       top = 1


两栈共享空间

这只是针对两个具有相同数据类型的栈的一个设计上的技巧。
使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。

数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，
即下标为数组长度 n - 1 处。这样，两个栈如果增加元素，就是两端点向中间延伸。

关键思路是:它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针。

栈1为空时，就是top1等于-1时; 而当top2等于n时，即是栈2为空。
若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。
但更多的情况，其实就是刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top+1 == top2
为栈满。


struct double_stack {
	ElemType data(MAXSTZE];
	int top1; /* 栈1栈顶指针 */
	int top2; /* 栈2栈顶指针 */
};

对于两栈共享空间的push方法，我们除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号
参数stackNumber。

int
push(double_stack_t *stack, ElemType *item, int num)
{
	/* if full */
	if (stack->top1 + 1 == stack->top2)
		return -1;

	/* 若栈1，则先top1+1后给数组元素赋值 */
	if (num == 1)
		stack->data[++stack->top1] = item;
	/* 若栈2，则先top2-1后给数组元素赋值 */
	else
		stack->data[--stack->top2] = item;

	return 0;
}

int
pop(double_stack_t *stack, ElemType *item, int num)
{
	if (num == 1) {
		/* if empty */
		if (stack->top1 == -1)
			return -1;

		*item = stack->data[stack->top1--];
	} else {
		if (stack->top2 == STACK_SIZE)
			return -1;

		*item = stack->data[stack->top2++];
	}

	return 0;
}



栈的链式存储结构及实现

栈的链式存储结构，简称为链栈。
通常对于链栈来说，是不需要头结点的。

                +----+-+   +------+-+           +----+------+
   头指针 top--->| an | +-->| an-1 | +--> ... -->| a1 | NULL |
                +----+-+   +------+-+           +----+------+
                 栈顶                             栈底

对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间。
对于空栈来说，链表原定义是头指针指向空， 那么链栈的空其实就是top=NULL的时候。


struct node {
	ElemType data;
	struct node next;
};

struct link_stack {
	struct node top;
	unsigned int count;
};


链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均为O(1)。
对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1) 。对于空间性能，顺序栈需要事先
确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求
每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中
讨论的一样， 如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，
如果它的变化在可控范围内，建议使用顺序栈会更好一些。


栈的应用 - 递归

斐波那契(Fibonacci)
如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔都不死，
那么一年以后可以繁殖多少对兔子呢?

这个数列有个十分明显的特点，那是:前面相邻两项之和，构成了后一项。

       /-  0，当n=O
F(n)= < -  1，当n=1
       \-  F(n-1)+F(n-2)，当n>1

int
fibonacci(int n)
{
	if (n < 2)
		return (n == 0) ? 0 : 1;
	else
		return fibonacci(n-1) + fibonacci(n-2);
}

把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。
每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理
解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。
迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。



栈的应用 - 四则运算表达式求值

后缀（逆波兰）表示法

对于"9+(3-1)*3+10/2"，如果要用后缀表示法应该是什么样子:"9 3 1 - 3 * + 10 2 / +"，
这样的表达式称为后缀表达式。所有的符号都是在要运算数字的后面出现。

中缀表达式(infix expression) 转 后缀表达式(postfix expression)
规则: 从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；
若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于前一个符号(乘除优先加减)则栈顶元素
依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

后缀表达式的计算
规则:从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，
进行运算，运算结果进栈，一直到最终获得结果。

要想让计算机具有处理我们通常的标准(中缀)表达式的能力，最重要的就是两步:
1. 将中缀表达式转化为后缀表达式(栈用来进出运算的符号)。
2. 将后缀表达式进行运算得出结果(栈用来进出运算的数字)。



队列的定义

队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
队列是一种先进先出(First In First Out)的线性表，简称FIFO 。允许插入的一端称为队尾，
允许删除的一端称为队头。

队列的抽象数据类型

ADT 队列( Queue)
Data
	同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
	InitQueue(*Q) : 初始化操作，建立一个空队列Q。
	DestroyQueue(*Q) : 若队列Q存在，则销毁它。
	ClearQueue(*Q) : 将队列Q清空。
	QueueEmpty(Q) : 若队列Q为空，返回true，否则返回false。
	GetHead(Q, *e) : 若队列Q存在且非空，用e返回队列Q的队头元素。
	EnQueue(*Q, e) : 若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
	DeQueue(*Q，*e) : 删除队列Q中队头元素，并用e返回其值。
	QueueLength(Q) : 返回队列Q的元素个数。
endADT

线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的钱性表，
也同样存在这两种存储方式。

队列顺序存储的不足
顺序存储的队列需建立一个大于n的数组，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在
队尾追加一个元素，不需要移动任何元素，因此时间复杂度为O(1)。
与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前
移动，以保证队列的队头，也就是下标为0的位置不为空，此时时间复杂度为O(n)。

循环队列
如果不去限制队列的元素必须存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头
不需要一定在下标为0的位置。为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个
指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当的front等于rear时，
此队列不是还剩一个元素，而是空队列。

我们把队列的这种头尾相接的顺序存储结构称为循环队列。

此时问题又出来了，我们刚才说，空队列时，fronr等于rear，现在当队列满时，也是frot等于rear，
那么如何判断此时的队列究竟是空还是满呢?
-> 办法一是设置一个标志变量flag，当front == rear，且flag = 0时为队列空，
   当front == rear，且flag= 1时为队列满。
-> 办法二是当队列空时，条件就是from = rear，当队列满时，我们修改其条件，保留一个元素空间。
   也就是说，队列满时，数组中还有一个空闲单元,我们就认为此队列已经满。

我们重点来讨论第二种方法，由于rear可能比front大，也可能比front 小，所以尽管它们只相差一个位
时就是满的情况，但也可能是相差整整一圈。

队列满的条件是 (rear+1) % QueueSize = front
front = 0 而rear = 4，(4+1) % 5 = 0，所以此时队列满；
front = 2 而rear = 1，(1+1) % 5 = 2，所以此时队列也是满的；
front = 2 而rear = 0, (0+1) % 5 = 1, 1 ！= 2 ，所以此时队列并没有满。

通用的计算队列长度公式为:
(rear - front + QueueSize) % QueueSize


循环队列的顺序存储结构
struct queue {
	ElemType data[QUEUE_SIZE];
	int front;
	int rear;
}

入对操作
insert_queue(queue_t queue, ElemType item)
{
	/* queue is full */
	if ((queue->rear + 1) % QUEUE_SZIE == queue->frot)
		return;

	queue->data[queue->rear + 1] = item;
	/* rear指针向后移一位置，若到最后则指向数组头部 */
	queue->rear = (queue->read + 1) % QUEUE_SIZE;
}

出对操作
delete_queue(queue_t queue, ElemType *item)
{
	/* queue is empty */
	if (queue->rear == queue->front)
		return;

	*item = queue->data[queue->front];
	/* front指针向后移一位置，若到最后则指向数组头部 */
	queue->front = (queue->front + 1) % QUEUE_SIZE;
}



队列的链式存储结构及实现

队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。
我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。

          头结点     对头                           对尾
          +--+-+   +----+-+   +----+-+           +----+------+
 front -->|  | +-->| a1 | +-->| a2 | +--> ... -->| an | NULL |<-- rear
          +--+-+   +----+-+   +----+-+           +----+------+

队列空时，front和rear都指向头结点，

            头结点
          +--+------+
 front -->|  | NULL +<-- rear
          +--+------+

struct node {
	ElemType data;
	struct node *next;
}

struct queue {
	struct node *front;
	struct node *rear;
}

入对操作
insert_queue(queue_t queue, ElemType item)
{
	struct node *ptr = (struct node *) malloc(sizeof(struct node));
	ptr->data = item;
	ptr->next = NULL;

	/* 在对尾插入新的元素 */
	queue->rear->next = ptr;
	/* 对尾指向新元素 */
	queue->rear = ptr;
}

出对操作
delete_queue(queue_t queue, ElemType *item)
{
	/* queue is empty */
	if (queue->front == queue->rear)
		return;

	struct node *ptr;
	/* ptr 指向头结点的下一个，即对头 */
	ptr = queue->front->next;
	*item = ptr->data;
	/* 头指针指向原对头的下一个元素 */
	queue->front->next = ptr->next;

	/* 若对头是对尾，则删除后将rear指向头结点，也就是队列为空 */
	if (queue->rear == ptr)
		queue->rear = queue->front;

	free(ptr);
}

总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。

--------------------------------------------------------------------------------

第5章 串

串(string)是由零个或多个字符组成的有限序列，又名叫字符串。一般记为 s= "a1a2...an"(n >= 0)。

子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。

子串的定位操作通常称做串的模式匹配。

朴素的模式匹配算法
就是对主串S的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做
T的长度的小循环，直到匹配成功或全部遍历完成为止。


KMP模式匹配算法
有待理解


--------------------------------------------------------------------------------

第6章 树

树(Tree)是n(n >= O)个结点的有限集。n=O时称为空树。在任意一棵非空树中: 
(1)有且仅有一个特定的称为根(Root)的结点;
(2)当n>1时，其余结点可分为m(m>O)个互不相交的有限集T1、T2、... 、Tm, 其中每一个集合本身
又是一颗树，并且称为根的子树(SubTree).

对于树的定义还需要强调两点:
1. n>0时根结点是唯一的
2. m>0时，子树的个数没有限制，但它们一定是互不相交的

树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。
度为0的结点称为叶结点(Leaf)或终端结点;度不为0的结点称为非终端结点或分支结点。除根结点之外，
分支结点也称为内部结点。树的度是树内各结点的度的最大值。
度是子树数，深度是数的层次。



双亲表示法

我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的
位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。

+------+--------+
| data | parent |
+------+--------+

其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。

struct node {
	ElemType data;	/* 结点数据 */
	int parent;	/* 双亲位置 */
};

struct tree {
	struct node nodes[SIZE];	/* 结点数组 */
	int root;			/* 根的位置 */
	int num;			/* 结点数 */
};


孩子表示法


孩子兄弟表示法



二叉树

二叉树(Binary Tree)是n(n>=O)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根
结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

二叉树的特点有:
每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。
左子树和右子树是有顺序的，次序不能任意颠倒。
即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

二叉树具有五种基本形态:
空二叉树。
只有一个根结点。
根结点只有左子树。
根结点只有右子树。
根结点既有左子树又有右子树。

所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为
斜树。

在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树
称为满二叉树。
满二叉树的特点有:
叶子只能出现在最下一层。
非叶子结点的度一定是2。
在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=) 的结点与同样深度的满二叉树中编号为i
的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
完全二叉树的特点:
叶子结点只能出现在最下两层。
最下层的叶子一定集中在左部连续位置。
倒数二层，若有叶子结点，一定都在右部连续位置。
如果结点度为1 ，则该结点只有左孩子，即不存在只有右子树的情况。
同样结点数的二叉树，完全二叉树的深度最小。


二叉树的性质：
性质1:在二叉树的第i层上至多有2^(i-1)个结点(i>=1)。
性质2:深度为k的二叉树至多有2^k - 1 个结点(k>=1)。
性质3:对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。终端结点数其实
     就是叶子结点数。
性质4:具有n个结点的完全二叉树的深度为
性质5:


二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的
链表叫做二叉链表。

struct bitree {
	ElemType data;			/* 结点数据 */
	struct bitree *lchild, *rchile;	/* 左右孩子 */
};

二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种次序依次访问二叉树中所有结点，
使得每个结点被访问一次且仅被访问一次。

1. 前序遍历
规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。
2. 中序遍历
规则是若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点) ，
中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。
3. 后序遍历
规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。
4. 层序遍历
规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，
在同一层中， 按从左到右的顺序对结点逐个访问。


二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。

前序遍历
void PreOrderTraverse(BiTree *T)
{
	if (T == NULL)
		return;
	printf("%C", T->data);	/* 显示给结点数据，可以更改为其他对结点的操作 */
	PreOrderTraverse(T->lchild);	/* 再先序遍历左子树 */
	PreOrderTraverse(T->rchild);	/* 最后先序遍历右子树 */
}

中序遍历
void InOrderTraverse(BiTree *T)
{
	if (T == NULL)
		return;
	InOrderTraverse(T->lchild);	/* 先中序遍历左子树 */
	printf("%C", T->data);	/* 显示给结点数据，可以更改为其他对结点的操作 */
	InOrderTraverse(T->rchild);	/* 最后中序遍历右子树 */
}

后序遍历
void PostOrderTraverse(BiTree *T)
{
	if (T == NULL)
		return;
	PostOrderTraverse(T->lchild);	/* 先后序遍历左子树 */
	PostOrderTraverse(T->rchild);	/* 然后后序遍历右子树 */
	printf("%C", T->data);	/* 显示给结点数据，可以更改为其他对结点的操作 */
}


二叉树的建立

为了能让每个结点确认是否有左右孩子，我们对它进行了扩展，也就是将二叉树中每个结点的空指针引出
一个虚结点，其值为一特定值，比如" # " 。我们称这种处理后的二叉树为原二叉树的扩展二叉树。
扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。

void CreateBiTree(BiTree *T)
{
	ElemType ch;
	scanf("%c", &ch);

	if (ch == '#') {
		*T = NULL;
	} else {
		*T = (BiTree) malloc(sizeof(BiTnode));
		(*T)->data = ch;
		CreateBiTree(&(*T)->lchild); /* 构造左子树 */
		CreateBiTree(&(*T)->rchild); /* 构造右子树 */
	}
}

其实建立二叉树，也是利用了递归的原理


线索二叉树:
我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为
线索二叉树(Threaded Binary Tree) 。


树，森林与二叉树的转换


赫夫曼编树
最基本的压缩编码方法一一赫夫曼编码。


--------------------------------------------------------------------------------

第7章 图


在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。
在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，
但只能和上一层中一个元素相关。这和一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。

图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个
数据元素之间都可能相关。

图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V，E)，其中，G表示一个图，
V是图G中顶点的集舍，E是图G中边的集合。

对于图的定义，我们需要明确几个注意的地方：
线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。
线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有顶点。在
定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。
线性表中，相邻的数据元素之间具有钱性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个
顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。


无向边:若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(Vi，Vj) 来表示。
如果图中任意两个顶点之间的边都是无向边，则称该图为无向图(Undirected graphs)。
A-----D
由于是无方向的，连接顶点A与D的边，可以表示成无序对(A,D)，也可以写成(D,A)。

有向边:若从顶点Vi到Vj的边有方向，则称这条边为有向边，也称为弧(Arc)。用有序偶<Vi, Vj>来表示，
Vi称为弧尾(Tail)，Vj称为弧头(Head)。如果图中任意两个顶点之间的边都是有向边，则称该图为
有向图(Directed grahs)。
A---->D
连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，<A, D>表示弧，注意不能写成<D，A>。

在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。我们课程里要讨论
的都是简单图。

在无向图中，如果任意两个顶点之间都存在边，则称该因为无向完全图。含有n个顶点的无向完全图有
n*(n-1)/2 条边。

在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点
的有向完全图有n*(n-1) 条边。

有很少条边或弧的图称为稀疏图，反之称为稠密图。这里稀疏和稠密是模糊的概念，都是相对而言的。

有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)。这种带权的图通常
称为网(Network) 。

对于无向图G=(V,{E})，如果边(v,v')属于E，则称顶点v和v'互为邻接点(Adjacent)，即v和v'相邻接。
边(v,v')依附(incident)于顶点v和v'，或者说(v,v')与顶点v和v'相关联。顶点v的度(Degree)是和v
相关联的边的数目，记为TD(v)。边数其实就是各顶点度数和的一半，多出的一半是因为重复两次记数。

对于有向图G=(V,{E})，如果弧<v,v'>属于E，则称顶点v邻接到顶点v'，顶点v'邻接自顶点v。弧<v,v'>
和顶点v，v'相关联。以顶点v为头的弧的数目称为v的入度(InDegree)，记为ID(v); 以v为尾的弧的数目
称为v的出度(OutDegree)，记为OD(v);顶点v 的度为TD(v)=ID(v)+OD(v)。

无向图G=(V,{E})中从顶点v到顶点v'的路径(Path)是一个顶点序列(v=...=v')，


树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。
路径的长度是路径上的边或弧的数目。

第一个顶点到最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复出现的路径称为简单路径。
除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

在无向图G 中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对于图中任意两个顶点vi、vj
属于E，vi和vj都是连通的，则称G是连通图(Connected Graph)。





























