
大话数据结构 - 程杰


Contents


1.数据结构绪论




--------------------------------------------------------------------------------

第1章  数据结构绪论


数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的
学科。

程序设计 = 数据结构 + 算法

数据:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号
集合。

数据元素:是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。

数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

数据对象:是性质相同的数据元素的集合，是数据的子集。


在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。
数据结构:是相互之间存在一种或多种特定关系的数据元素的集舍。


数据结构分为逻辑结构和物理结构

逻辑结构:是指数据对象中数据元素之间的相互关系
逻辑结构分为以下四种:
1. 集合结构
集合结构:集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
2. 线性结构
线性结构:统性结构中的数据元素之间是一对一的关系。
3. 树形结构
树形结构:树形结构中的数据元素之间存在一种一对多的层次关系。
4. 图形结构
图形结构:图形结构的数据元素是多对多的关系。

数据的物理结构，也叫做存储结构。
物理结构:是指数据的逻辑结构在计算机中的存储形式。

数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的
逻辑关系，是实现物理结构的重点和难点。
数据元素的存储结构形式有两种:顺序存储和链式存储。
1. 顺序存储结构
顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
2. 链式存储结构
链式存储结构:是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就
可以找到相关联数据元素的位置。

逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到
计算机的内存中。


数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

在C语言中，按照取值的不同，数据类型可以分为两类;
原子类型:是不可以再分解的基本类型，包括整型、实型、字符型等。
结构类型:由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。

抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个
概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。

抽象数据类型(Abstract Data Type，ADT) : 是指一个数学模型及定义在该模型上的一组操作。
一个抽象数据类型定义了:一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。

事实上，抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的
问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的
实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。


描述抽象数据类型的标准格式:

ADT	抽象数据类型名
Data
	数据元素之间逗得关系的定义
Operation
	操作1
		初始条件
		操作结果描述
	操作2
		......
	操作n
		......
endADT


总结：
+------------------------------------+
|                数据                 |
+------------------------------------+
|               数据对象              |
+-----------------++-----------------+
|     数据元素     ||     数据元素      |
+--------+--------++--------+--------+
| 数据项1 | 数据项2 || 数据项1 | 数据项2 |
+--------+--------++--------+--------+

+-----------+
|  逻辑结构  |
+-----------+
| - 集合结构 |
| - 线性结构 |
| - 树形结构 |
| - 图形结构 |
+-----------+

+--------------+
|    物理结构   |
+--------------+
| - 顺序存储结构 |
| - 链接存储结构 |
+--------------+


--------------------------------------------------------------------------------

第2章  算法


在《数据结构》课程中，就算谈到算法，也是为了帮助理解好数据结构，并不会详细谈及算法的方方面面。

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特性: 输入、输出、有穷性、确定性和可行性。

输入和输出：
算法具有零个或多个输入，算法至少有一个或多个输出。
有穷性：
指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
确定性：
算法的每一步骤都具有确定的含义，不会出现二义性。
可行性：
算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

算法不是唯一的，也就是说，同一个问题，可以有多种解决问题的算法。


正确性:算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、
能够得到问题的正确答案。
算法的"正确"通常在用法上有很大的差别，大体分为以下四个层次。
1. 算法程序没有语法错误。
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。
算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有
层次上都是正确的，代价非常昂贵。所以一般情况下，把层次3作为一个算法是否正确的标准。

可读性: 算法设计的另一目的是为了便于阅读、理解和交流。
我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和
交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。

健壮性:当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

时间效率高和存储量低:好的算法还应该具备时间效率高和存储量低的特点。

综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。


算法效率的度量方法

事后统计方法:这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的
运行时间进行比较，从而确定算法效率的高低。
事前分析估算方法:在计算机程序编制前，依据统计方法对算法进行估算。

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素:
1. 算法采用的策略、方法。
2. 编译产生的代码质量。
3. 问题的输入规模。
4. 机器执行指令的速度。
一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。


第一个例子
写一个求1+2+3+...+100结果的程序

版本一：
int i, sum, n;
sum = 0, n = 100;
for (i = 1; i <= n; ++i)
	sum += i;		/* 执行n次 */

版本二：
int i, sum, n;
sum = 0, n = 100;
sum = (1 + n) * n / 2;		/* 执行1次 */

我们把循环看作一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是n次与1次的差距。


第二个例子

int i, j, x = 0, sum = 0, n = 100;
for (i = 1; i <= n; ++i) {
	for (j = 1; j <= n; ++j) {
		++x;
		sum += x;	/* 执行nxn次 */
	}
}
这个例子中，i从1到100，每次都要让j循环100次，而当中的x++和sum = sum + x; 其实就是
1+2+3+...+10000，也就是100^2次。所以这个算法当中，循环部分的代码整体需要执行n^2 
(忽略循环体头尾的开销)次。


测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数，运行时间与这个计数成正比。

我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心
它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变童声明、打印结果等操作，最终，
在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。

可以从问题描述中得到启示，同样问题的输入规模是n，求和算法的第一种，求1+2+...+n需要一段代码
运行n次。那么这个问题的输入规模使得操作数量是 f(n) = n，显然运行100次的同一段代码规模是运算
10次的10倍。而第二种，无论n为多少，运行次数都为1，即 f(n) = 1; 第三种，运算100次是运算10次
的100倍。因为它是 f(n) = n^2。

我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量
必须表示成输入规模的函数。
我们可以这样认为，随着n值的越来越大，它们在时间效率上的差异也就越来越大。


输入规模n 在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是
渐近增长的。
函数的渐近增长:给定两个函数 f(n) 和 g(n)，如果存在一个整数N，使得对于所有的 n > N,
f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。

我们可以忽略这些加法常数；
与最高次项相乘的常数并不重要
最高次项的指数大的，函数随着 n 的增长，结果也会变得增长特别快。

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数。

某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。这其实就是事前估算方法
的理论依据，通过算法时间复杂度来估算算法时间效率。


算法时间复杂度定义

在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化
情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作: T(n) = O(f(n))。
它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，
简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函敬。

这样用大写 O() 来体现算法时间复杂度的记法，我们称之为 大O记法。
一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。
显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为 O(n)，O(1)，O(n^2)。
我们分别给它们取了非官方的名称，O(1) 叫常数阶、O(n) 叫线性阶、O(n^2) 叫平方阶。


推导大O阶:
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常敢。
得到的结果就是大O阶。


常数阶
首先顺序结构的时间复杂度。
int sum = 0, n = 100;	/* 执行一次 */
sum = (1 + n) / 2;	/* 执行一次 */
printf("%d", sum);	/* 执行一次 */
这个算法的时间复杂度为 O(1)。
这种与问题的大小无关( n 的多少)，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度，又
叫常数阶。

线性阶
线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行
的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。
int i;
for (i = 0; i < n; ++i) {
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
循环的时间复杂度为 O(n)，因为循环体中的代码须要执行n次。

对数阶
int count = 1;
while (count < n) {
	count = count * 2;
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
由于每次 count 乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。
由 2^x=n 得到 x=log2(n)。所以这个循环的时间复杂度为 O(log n)。

平方阶
int i, j;
for (i = 0; i < n; ++i) {
	for (j = 0; j < n; ++j) {
		/* 时间复杂度为 O(1) 的程序步骤序列 */
	}
}
对于外层的循环，不过是内部这个时间复杂度为O(n)的语旬，再循环n次。所以这段代码的时间复杂度为
O(n^2).


常用的时间复杂度所耗费的时间从小到大依次是:
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
常数阶  对数阶    线性阶   nlogn阶    平方阶     立方阶    指数阶   阶乘阶


最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，
除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。
对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另
一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，
都是指最坏时间复杂度。


算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作: 
S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。


--------------------------------------------------------------------------------












