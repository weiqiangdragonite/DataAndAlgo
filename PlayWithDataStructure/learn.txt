
大话数据结构 - 程杰


Contents


1.数据结构绪论




--------------------------------------------------------------------------------

第1章  数据结构绪论


数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的
学科。

程序设计 = 数据结构 + 算法

数据:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号
集合。

数据元素:是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。

数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

数据对象:是性质相同的数据元素的集合，是数据的子集。


在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。
数据结构:是相互之间存在一种或多种特定关系的数据元素的集舍。


数据结构分为逻辑结构和物理结构

逻辑结构:是指数据对象中数据元素之间的相互关系
逻辑结构分为以下四种:
1. 集合结构
集合结构:集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
2. 线性结构
线性结构:统性结构中的数据元素之间是一对一的关系。
3. 树形结构
树形结构:树形结构中的数据元素之间存在一种一对多的层次关系。
4. 图形结构
图形结构:图形结构的数据元素是多对多的关系。

数据的物理结构，也叫做存储结构。
物理结构:是指数据的逻辑结构在计算机中的存储形式。

数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的
逻辑关系，是实现物理结构的重点和难点。
数据元素的存储结构形式有两种:顺序存储和链式存储。
1. 顺序存储结构
顺序存储结构:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
2. 链式存储结构
链式存储结构:是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就
可以找到相关联数据元素的位置。

逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到
计算机的内存中。


数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

在C语言中，按照取值的不同，数据类型可以分为两类;
原子类型:是不可以再分解的基本类型，包括整型、实型、字符型等。
结构类型:由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。

抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个
概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。

抽象数据类型(Abstract Data Type，ADT) : 是指一个数学模型及定义在该模型上的一组操作。
一个抽象数据类型定义了:一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。

事实上，抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的
问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的
实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。


描述抽象数据类型的标准格式:

ADT	抽象数据类型名
Data
	数据元素之间逗得关系的定义
Operation
	操作1
		初始条件
		操作结果描述
	操作2
		......
	操作n
		......
endADT


总结：
+------------------------------------+
|                数据                 |
+------------------------------------+
|               数据对象              |
+-----------------++-----------------+
|     数据元素     ||     数据元素      |
+--------+--------++--------+--------+
| 数据项1 | 数据项2 || 数据项1 | 数据项2 |
+--------+--------++--------+--------+

+-----------+
|  逻辑结构  |
+-----------+
| - 集合结构 |
| - 线性结构 |
| - 树形结构 |
| - 图形结构 |
+-----------+

+--------------+
|    物理结构   |
+--------------+
| - 顺序存储结构 |
| - 链接存储结构 |
+--------------+


--------------------------------------------------------------------------------

第2章  算法


在《数据结构》课程中，就算谈到算法，也是为了帮助理解好数据结构，并不会详细谈及算法的方方面面。

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特性: 输入、输出、有穷性、确定性和可行性。

输入和输出：
算法具有零个或多个输入，算法至少有一个或多个输出。
有穷性：
指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
确定性：
算法的每一步骤都具有确定的含义，不会出现二义性。
可行性：
算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

算法不是唯一的，也就是说，同一个问题，可以有多种解决问题的算法。


正确性:算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、
能够得到问题的正确答案。
算法的"正确"通常在用法上有很大的差别，大体分为以下四个层次。
1. 算法程序没有语法错误。
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。
算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有
层次上都是正确的，代价非常昂贵。所以一般情况下，把层次3作为一个算法是否正确的标准。

可读性: 算法设计的另一目的是为了便于阅读、理解和交流。
我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和
交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。

健壮性:当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

时间效率高和存储量低:好的算法还应该具备时间效率高和存储量低的特点。

综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。


算法效率的度量方法

事后统计方法:这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的
运行时间进行比较，从而确定算法效率的高低。
事前分析估算方法:在计算机程序编制前，依据统计方法对算法进行估算。

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素:
1. 算法采用的策略、方法。
2. 编译产生的代码质量。
3. 问题的输入规模。
4. 机器执行指令的速度。
一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。


第一个例子
写一个求1+2+3+...+100结果的程序

版本一：
int i, sum, n;
sum = 0, n = 100;
for (i = 1; i <= n; ++i)
	sum += i;		/* 执行n次 */

版本二：
int i, sum, n;
sum = 0, n = 100;
sum = (1 + n) * n / 2;		/* 执行1次 */

我们把循环看作一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是n次与1次的差距。


第二个例子

int i, j, x = 0, sum = 0, n = 100;
for (i = 1; i <= n; ++i) {
	for (j = 1; j <= n; ++j) {
		++x;
		sum += x;	/* 执行nxn次 */
	}
}
这个例子中，i从1到100，每次都要让j循环100次，而当中的x++和sum = sum + x; 其实就是
1+2+3+...+10000，也就是100^2次。所以这个算法当中，循环部分的代码整体需要执行n^2 
(忽略循环体头尾的开销)次。


测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数，运行时间与这个计数成正比。

我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心
它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变童声明、打印结果等操作，最终，
在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。

可以从问题描述中得到启示，同样问题的输入规模是n，求和算法的第一种，求1+2+...+n需要一段代码
运行n次。那么这个问题的输入规模使得操作数量是 f(n) = n，显然运行100次的同一段代码规模是运算
10次的10倍。而第二种，无论n为多少，运行次数都为1，即 f(n) = 1; 第三种，运算100次是运算10次
的100倍。因为它是 f(n) = n^2。

我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量
必须表示成输入规模的函数。
我们可以这样认为，随着n值的越来越大，它们在时间效率上的差异也就越来越大。


输入规模n 在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是
渐近增长的。
函数的渐近增长:给定两个函数 f(n) 和 g(n)，如果存在一个整数N，使得对于所有的 n > N,
f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。

我们可以忽略这些加法常数；
与最高次项相乘的常数并不重要
最高次项的指数大的，函数随着 n 的增长，结果也会变得增长特别快。

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数。

某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。这其实就是事前估算方法
的理论依据，通过算法时间复杂度来估算算法时间效率。


算法时间复杂度定义

在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化
情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作: T(n) = O(f(n))。
它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，
简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函敬。

这样用大写 O() 来体现算法时间复杂度的记法，我们称之为 大O记法。
一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。
显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为 O(n)，O(1)，O(n^2)。
我们分别给它们取了非官方的名称，O(1) 叫常数阶、O(n) 叫线性阶、O(n^2) 叫平方阶。


推导大O阶:
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常敢。
得到的结果就是大O阶。


常数阶
首先顺序结构的时间复杂度。
int sum = 0, n = 100;	/* 执行一次 */
sum = (1 + n) / 2;	/* 执行一次 */
printf("%d", sum);	/* 执行一次 */
这个算法的时间复杂度为 O(1)。
这种与问题的大小无关( n 的多少)，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度，又
叫常数阶。

线性阶
线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行
的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。
int i;
for (i = 0; i < n; ++i) {
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
循环的时间复杂度为 O(n)，因为循环体中的代码须要执行n次。

对数阶
int count = 1;
while (count < n) {
	count = count * 2;
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
由于每次 count 乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。
由 2^x=n 得到 x=log2(n)。所以这个循环的时间复杂度为 O(log n)。

平方阶
int i, j;
for (i = 0; i < n; ++i) {
	for (j = 0; j < n; ++j) {
		/* 时间复杂度为 O(1) 的程序步骤序列 */
	}
}
对于外层的循环，不过是内部这个时间复杂度为O(n)的语旬，再循环n次。所以这段代码的时间复杂度为
O(n^2).


常用的时间复杂度所耗费的时间从小到大依次是:
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
常数阶  对数阶    线性阶   nlogn阶    平方阶     立方阶    指数阶   阶乘阶


最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，
除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。
对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另
一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，
都是指最坏时间复杂度。


算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作: 
S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。


--------------------------------------------------------------------------------

第三章  线性表


线性表(List):零个或多个数据元素的有限序列。

若将线性表记为(a1, ... , ai-1, ai, ai+1, ... , an)，则表中 ai-1 领先于 ai，ai 领
先于 ai+1，称 ai-1 是 ai 的直接前驱元素， ai+1 是 ai 的直接后继元素。当 i=1, 2, ... ,
n-1 时， ai 有且仅有一个直接后继，当 i=2, 3, ... , n 时，ai 有且仅有一个直接前驱。

线性表元素的个数 n( n >= 0 ) 定义为线性表的长度，当 n=0 时，称为空表。
在较复杂的线性表中，一个数据元素可以由若干个数据项组成。


线性表的抽象数据类型定义如下:

ADT 线性表(List)
Data
	线性表的数据对象集合为 {a1, a2, ... , an}，每个元素的类型均为 DataType。其中，
	除第一个元素 a1 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，
	每一个元素有且只有一个后继元素。数据元素之间的关系是一对一的关系。
Operation
	InitList(*L) : 初始化操作，建立一个空的线性表 L。
	ListEmpty(L) : 若线性表为空，返回true，否则返回false。
	ClearList(*L) : 将线性表清空。
	GetElem(L, i, *e) : 将线性表 L 中的第 i 个位置元素值返回给 e。
	LocateElem(L, e) : 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回
                           该元素在表中序号表示成功；否则，返回0表示失败。
	ListInsert(*L, i, e) : 在线性表 L 中的第 i 个位置插入新元素 e。
	ListDelete(*L, i, *e) : 删除线性表 L 中第 i 个位置元素，并用 e 返回其值。
	ListLength(L) : 返回线性表 L 的元素个数。
endADT


线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

线性表的顺序存储的结构代码：
#define MAXSIZE	20	/* 存储空间的初始分配量 */
typedef int ElemType;	/* ElemType 类型根据实际情况而定 */
typedef struct sequence_list {
	ElemType data[MAXSIZE];	/* 数组存储数据元素，最大值为MAXSIZE */
	int length;		/* 线性表当前长度 */
};

描述顺序存储结构需要三个属性:
1. 存储空间的起始位置: 数组data，它的存储位置就是存储空间的存储位置。
2. 线性表的最大存储容量: 数组长度MAXSIZE。
3. 线性表的当前长度: length。

在任意时刻，线性表的长度应该小于等于数组的长度。

假设每个数据元素占用 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的
存储位置满足下列关系(LOC 表示获得存储位置的函数):
LOC(ai+1) = LOC(ai) + c
对于第 i 个数据元素 ai 的存储位置可以由 a1 推算得出:
LOC(ai) = LOC(a1) + (i-1) * c

我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间,也就是一个常数，因此用
我们算法中学到的时间复杂度的概念来说，它的存取时间性能为 O(1)。我们通常把具有这一特点的
存储结构称为随机存取结构。

插入算法的思路;
1. 如果插入位置不合理，抛出异常;
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量;
3. 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置;
4. 将要插入元素填入位置 i 处;
5. 表长加1。

删除算法的思路:
1. 如果删除位置不合理，抛出异常；
2. 取出删除元素;
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置;
4. 表长减1。

如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为 O(1)
如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，
所以这个时间复杂度为 O(n)。
至于平均的情况，由于元素插入到第 i 个位置，或删除第 i 个元素，需要移动 n - i 个元素。最终
平均移动次数和最中间的那个元素的移动次数相等，为 (n-1)/2。可以得出，平均时间复杂度还是 O(n)。

线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 O(1); 
而插入或删除时，时间复杂度都是 O(n)。



线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，
也可以是不连续的。

在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。

为了表示每个数据元素 ai 与其直接后继数据元素 ai+1 之间的逻辑关系，对数据元素 ai 来说，除了
存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据
元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。
这两部分信息组成数据元素 ai 的存储映像，称为结点(Node) 。

n个结点(ai 的存储映像) 链结成一个链表，即为线性表( a1, a2, ... , an ) 的链式存储结构，
因为此链表的每个结点中只包含一个指针域，所以叫做单链表。

链表中第一个结点的存储位置叫做头指针。最后一个，当然就意味着直接后继不存在了，所以我们规定，
线性链表的最后一个结点指针为"空" (通常用 NULL 或 ^ 符号表示)

头指针
+----+-+   +----+-+           +----+------+
| a1 | +-->| a2 | +--> ... -->| an | NULL |
+----+-+   +----+-+           +----+------+

有时，我们为了更加方便地对链装进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。
头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针。

头结点
+--+-+   +----+-+   +----+-+           +----+------+
|  | +-->| a1 | +-->| a2 | +--> ... -->| an | NULL |
+--+-+   +----+-+   +----+-+           +----+------+

线性表的存储结构
struct link_list {
	ElemType data;
	struct link_list next;
};

             p            p->next
          +------+-+   +--------+-+
       -->|  ai  | +-->|  ai+1  | +-->
          +--+---+-+   +---+----+-+
             |             |
             V             V
         p->data       p->next->data

获得单链表第 i 个数据的算法思路:
1.声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始;
2.当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1;
3.若到链表末尾 p 为空，则说明第 i 个元素不存在;
4.否则查找成功，返回结点 p 的数据。

单链表第 i 个数据插入结点的算法思路:
1.声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始
2.当 j<i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1;
3.若到链表末尾 p 为空，则说明第 i 个元素不存在
4.否则查找成功，在系统中生成一个空结点 s;
5.将数据元素 e 赋值给 s->data ;
6.单链表的插入标准语句 s->next=p->next, p->next=s
7.返回成功。

单链表第 i 个数据删除结点的算法思路:
1.声明一结点 p 指向链表第一个结点， 初始化 j 从1 开始
2.当 j<i 时，就遍历链表， 让 p 的指针向后移动，不断指向下一个结点，j 累加 1
3.若到链表末尾 p 为空，则说明第 i 个元素不存在;
4.否则查找成功，将欲删除的结点 p->next 赋值给q;
5.单链表的删除标准语句 p->next=q->next;
6.将 q 结点中的数据赋值给 e ，作为返回;
7.释放 q 结点;
8.返回成功。

单链表整表创建的算法思路:
1.声明一结点 p 和计数器变量 i;
2.初始化一空链表L;
3.让 L 的头结点的指针指向NULL，即建立一个带头结点的单链表
4.循环:
  生成一新结点赋值给 p;
  随机生成一数字赋值给 p 的数据域 p->data;
  将 p 插入到头结点与前一新结点之间。

头插法 和 尾插法

单链表整表删除的算法思路如下:
1.声明一结点 p 和q ;
2.将第一个结点赋值给p;
3.循环:
  将下一结点赋值给q;
  释放p;
  将 q 赋值给p 。








